\begin{mathpar}
\inferrule* [right=ESFieldAssign]
{\evalex {\Heap} {\rho} {x} {o}\\\evalex {\Heap} {\rho} {y} {v_y}\\( o , f ) \in A\\ \Heap' = \Heap[o{\:\mapsto\:}[f{\:\mapsto\:}v_y]] }
{{( \Heap , ( \rho , A , x{\::=\:}f.y; \overline{s} ) \cdot S )} \rightarrow {( \Heap' , ( \rho , A , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESVarAssign]
{\evalex {\Heap} {\rho} {e} {v}\\ \rho' = \rho[x{\:\mapsto\:}v] }
{{( \Heap , ( \rho , A , x{\::=\:}e; \overline{s} ) \cdot S )} \rightarrow {( \Heap , ( \rho' , A , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESNewObj]
{ \Heap(o) = \bot \\ \fields(C) = Cf' \\ \rho' = \rho[x{\:\mapsto\:}o] \\ A' = A * map  (fun cf' => (o, snd cf'))  Cf' \\ \Heap' = HSubsts  o  (map (fun cf' => (snd cf', vnull)) Cf')  Heap }
{{( \Heap , ( \rho , A , x{\::=\:\new\:}C; \overline{s} ) \cdot S )} \rightarrow {( \Heap' , ( \rho' , A' , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESReturn]
{\evalex {\Heap} {\rho} {x} {v_x}\\ \rho' = \rho[\xresult{\:\mapsto\:}v_x] }
{{( \Heap , ( \rho , a , {\return}x; \overline{s} ) \cdot S )} \rightarrow {( \Heap , ( \rho' , a , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESApp]
{\evalex {h} {r} {y'} {o'}\\\evalex {h} {r} {z'} {v'}\\ h  o' = ( C' , fvf ) \\ mbody  C'  m' = rs \\ mparam  C'  m' = ( T , w' ) \\ \mpre(C',m') = pre \\ r' = ( fun  rx => if  x_decb  rx  xthis  
      then  Some  (vo o') 
      else  (if x_decb rx w' 
        then Some v'
        else None
      ) ) \\\evalphix {h} {r'} {A} {pre}\\ A' = \texttt{footprint}_{h,r'}(pre) }
{{( h , ( r , A , x'{\::=\:}y'.m'(z') * s' ) \cdot S' )} \rightarrow {( h , ( r' , A' , rs ) * ( r , Aexcept  A  A' , x'{\::=\:}y'.m'(z') * s' ) \cdot S' )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESAppFinish]
{ \mpost(C,m) = \phi \\\evalphix {\Heap} {\rho'} {A'} {\phi}\\ A'' = \texttt{footprint}_{\Heap,\rho'}(\phi) \\\evalex {\Heap} {\rho'} {\xresult} {v_r}}
{{( \Heap , ( \rho' , A' , \emptyset ) * ( \rho , A , x{\::=\:}y.m(zs'); \overline{s} ) \cdot S )} \rightarrow {( \Heap , ( \rho[x{\:\mapsto\:}v_r] , A * A'' , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESAssert]
{\evalphix {\Heap} {\rho} {A} {\phi}}
{{( \Heap , ( \rho , A , {\assert}\phi; \overline{s} ) \cdot S )} \rightarrow {( \Heap , ( \rho , A , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

\begin{mathpar}
\inferrule* [right=ESRelease]
{\evalphix {\Heap} {\rho} {A} {\phi}\\ A' = Aexcept  A  (footprint' Heap rho phi) }
{{( \Heap , ( \rho , A , {\release}\phi; \overline{s} ) \cdot S )} \rightarrow {( \Heap , ( \rho , A' , \overline{s} ) \cdot S )}}
\end{mathpar}\hfill

