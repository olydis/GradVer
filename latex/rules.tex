\documentclass[11pt,a4paper]{article}
%twocolumn
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{syntax}
\usepackage{lscape}
\usepackage{stmaryrd}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{mathpartir}
%\usepackage[pdftex]{graphicx}

%\usetikzlibrary{positioning,calc}

\DeclareMathSymbol{\mlq}{\mathord}{operators}{``}
\DeclareMathSymbol{\mrq}{\mathord}{operators}{`'}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}


\def\extraVskip{3pt}
\newenvironment{scprooftree}[1]%
  {\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
  {\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }

\makeatletter
\providecommand{\bigsqcap}{%
  \mathop{%
    \mathpalette\@updown\bigsqcup
  }%
}
\newcommand*{\@updown}[2]{%
  \rotatebox[origin=c]{180}{$\m@th#1#2$}%
}
\makeatother

\setlength{\parindent}{0cm}


\begin{document}
\pagenumbering{arabic}


\newcommand{\hasTypePremise}[3]{[#1 : #2]_{#3}}
\newcommand{\hasTypeFormula}[3]{{\llbracket #1 : #2\rrbracket}_{#3}}
\newcommand{\accFor}[1]{\llbracket #1 \rrbracket}

\newcommand{\Heap}{H}

\newcommand{\sfrme}{\ensuremath{\vdash_\texttt{sfrm}}}
\newcommand{\sfrmphi}{\ensuremath{\vdash_\texttt{sfrm}}}
\newcommand{\true}{\ensuremath{\texttt{true}}}
\newcommand{\vnull}{\ensuremath{\texttt{null}}}
\newcommand{\Tint}{\ensuremath{\texttt{int}}}
\newcommand{\xresult}{\ensuremath{\texttt{result}}}
\newcommand{\xthis}{\ensuremath{\texttt{this}}}
\newcommand{\new}{\ensuremath{\texttt{new}~}}
\newcommand{\assert}{\ensuremath{\texttt{assert}~}}
\newcommand{\release}{\ensuremath{\texttt{release}~}}
\newcommand{\return}{\ensuremath{\texttt{return}~}}
\newcommand{\acc}{\ensuremath{\texttt{acc}}}
\newcommand{\fields}{\ensuremath{\texttt{fields}}}
\newcommand{\mpre}{\ensuremath{\texttt{mpre}}}
\newcommand{\mpost}{\ensuremath{\texttt{mpost}}}
\newcommand{\mbody}{\ensuremath{\texttt{mbody}}}
\newcommand{\mparam}{\ensuremath{\texttt{mparam}}}
\newcommand{\mrettype}{\ensuremath{\texttt{mrettype}}}
\newcommand{\mmethod}{\ensuremath{\texttt{mmethod}}}

%\newcommand{\staticFP}[1]{\ensuremath{\texttt{static-footprint}(#1)}}
%\newcommand{\dynamicFP}[3]{\ensuremath{\texttt{footprint}_{#1,#2}(#3)}}

\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
\newcommand{\staticFP}[1]{\ensuremath{\floor{#1}}}
\newcommand{\dynamicFP}[3]{\ensuremath{\floor{#3}_{#1,#2}}}

\newcommand{\rlabel}[1]{\RightLabel{\quad #1}}
\newcommand{\dom}{\ensuremath{\texttt{dom}}}

\newcommand{\class}{\ensuremath{\texttt{class}~}}
\newcommand{\requires}{\ensuremath{\texttt{requires}~}}
\newcommand{\ensures}{\ensuremath{\texttt{ensures}~}}

\newcommand{\grad}[1]{\widetilde{#1}}
\newcommand{\withqm}[1]{?\:*\:#1}

\newcommand{\hoare}[3]{\vdash\{#1\}#2\{#3\}}
\newcommand{\ghoare}[3]{\grad{\vdash}\{#1\}#2\{#3\}}

\section{Syntax}

\begin{align*}
\\ &program    	&&::= \overline{cls}~\overline{s}
\\ &cls    		&&::= \class C~\{\overline{field}~\overline{method}\}
\\ &field    	&&::= T~f;
\\ &method		&&::= T~m(T~x)~contract~\{\overline{s}\}
\\ &contract	&&::= \requires \phi;~\ensures \phi;
\\ &T			&&::= \Tint ~|~ C
\\ &s			&&::= x.f := y;
				  ~|~ x := e; 
				  ~|~ x := \new C; 
				  ~|~ x := y.m(z);
\\ & &&
				  ~|~ \return x; 
				  ~|~ \assert \phi; 
				  ~|~ \release \phi;
				  ~|~ T~x;
\\ &\phi		&&::= \true
				  ~|~ e = e
				  ~|~ e \neq e
				  ~|~ \acc(e.f)
				  ~|~ \phi * \phi
\\ &e			&&::= v
				  ~|~ x
				  ~|~ e.f
\\ &x			&&::= \xthis ~|~ \xresult ~|~ \langle other \rangle
\\ &v			&&::= o ~|~ n ~|~ \vnull
\\ &n			&&\in~~ \mathbb{Z}
\\				  
\\ &H			&&\in~~ (o \rightharpoonup (C,\overline{(f \rightharpoonup v)}))
\\ &\rho		&&\in~~ (x \rightharpoonup v)
\\ &\Gamma		&&\in~~ (x \rightharpoonup T)
\\ &A_s			&&::= \overline{(e, f)}
\\ &A_d			&&::= \overline{(o, f)}
\\ &S			&&::= (\rho, A_d, \overline{s}) \cdot S ~|~ nil
\end{align*}

\newcommand{\OK}{~\texttt{OK}}
\newcommand{\OKinC}{~\texttt{OK in}~C}
\section{Assumptions}
All the rules in the following sections are implicitly parameterized over a $program p$ that is well-formed.

\subsubsection{Well-formed program ($program \OK$)}
\begin{mathpar}
\inferrule* [Right=OKProgram]
{
\overline{cls_i \OK}
}
{(\overline{cls_i}~\overline{s}) \OK}
\end{mathpar}

\subsubsection{Well-formed class ($cls \OK$)}
\begin{mathpar}
\inferrule* [Right=OKClass]
{
\text{unique $field$-names} \\
\text{unique $method$-names} \\
\overline{method_i \OKinC}
}
{(\class C~\{\overline{field_i}~\overline{method_i}\}) \OK}
\end{mathpar}

\subsubsection{Well-formed method ($method \OKinC$)}
\begin{mathpar}
\inferrule* [Right=OKMethod]
{
FV(\phi_1) \subseteq \{ x, \xthis \} \\
FV(\phi_2) \subseteq \{ x, \xthis, \xresult \} \\
x : T_x, \xthis : C, \xresult : T_m \hoare {\phi_1} {\overline{s}} {\phi_2} \\
\emptyset \sfrmphi {\phi_1} \\
\emptyset \sfrmphi {\phi_2} \\
\overline{\neg writesTo(s_i, x)}
}
{(T_m~m(T_x~x)~\requires \phi_1;~\ensures \phi_2;~\{\overline{s}\}) \OKinC}
\end{mathpar}


\section{Static semantics}
\subsection{Expressions ($A_s \sfrme e$)}
\input{staticExpression}

\subsection{Formulas ($A_s \sfrme \phi$)}
\input{staticFormula}

\begin{mathpar}
\inferrule* [Right=WFSepOp]
{
A_s \sfrmphi \phi_1 \\ 
A_s \cup \staticFP {\phi_1} \sfrmphi \phi_2
}
{A_s \sfrmphi \phi_1 * \phi_2}
\end{mathpar}

\subsubsection{Implication ($\phi_1 \dot{\implies} \phi_2$)}
Conservative approx. of $\phi_1 \implies \phi_2$.

\subsection{Footprint ($\staticFP {\phi} = A_s$)}
\begin{align*}
 &\staticFP {\true}    		&&= \emptyset
\\ &\staticFP {e_1 = e_2}     	&&= \emptyset
\\ &\staticFP {e_1 \neq e_2}  	&&= \emptyset
\\ &\staticFP {\acc(e.f)} 		&&= \{(e,f)\}
\\ &\staticFP {\phi_1 * \phi_2} 	&&= \staticFP {\phi_1} \cup \staticFP {\phi_2}
\end{align*}

\newcommand{\sType}[3]{#1 \vdash #2 : #3}
\subsection{Type ($\sType {\Gamma} {e} {T}$)}
%\begin{mathpar}
%\inferrule* [Right=STValue]
%{~}
%{\sType {\phi} {\null} {T}}
%\end{mathpar}
\begin{mathpar}
\inferrule* [Right=STValNum]
{~}
{\sType {\Gamma} {n} {\Tint}}
\end{mathpar}
\begin{mathpar}
\inferrule* [Right=STValNull]
{~}
{\sType {\Gamma} {\vnull} {T}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=STVar]
{\Gamma(x) = T}
{\sType {\Gamma} {x} {T}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=STField]
{ \sType {\Gamma} {e} {C}
\\ \vdash C.f : T}
{\sType {\Gamma} {e.f} {T}}
\end{mathpar}

\subsection{Hoare ($\Gamma \hoare {\phi} {\overline s} {\phi}$)}
\input{staticSemantics}
\subsubsection{Notation}
\input{staticSemanticsNotation}
\subsubsection{Deterministic}
\input{staticSemanticsDeterm}

\subsubsection{HApp determinism discussion}
\begin{mathpar}
    \inferrule* [Right=HApp]
    {{\Gamma} \vdash {{y}} : {{C}}\\
        {\mmethod({C}, {m})} = {{{T_r}~{m}({T_p}~{z})~{\requires {\phi_{pre}};~\ensures {\phi_{post}};}~\{ {\_} \}}}\\
        {\Gamma} \vdash {{x}} : {T_r}\\{\Gamma} \vdash {{z'}} : {T_p}\\
        {\phi} \implies {{({{y}} \neq {{\vnull}})} * {{\phi_p} * {\phi_r}}}\\
        {\emptyset} \sfrmphi {\phi_r}\\
        {x} \not \in {FV(\phi_r)}\\
        x \neq y \wedge x \neq z'\\
        {\phi_p} = {{\phi_{pre}}[{y}, {z'} / {\xthis}, {{z}}]}\\
        {\phi_q} = {{\phi_{post}}[{y}, {z'}, {x} / {\xthis}, {{z}}, {\xresult}]}}
    {\Gamma \hoare {\phi} {{x} := {y}.{m}({z'})} {{\phi_q} * {\phi_r}}}
\end{mathpar}

\begin{mathpar}
    \inferrule* [Right=HAppD]
    {{\Gamma} \vdash {{y}} : {{C}}\\
        {\mmethod({C}, {m})} = {{{T_r}~{m}({T_p}~{z})~{\requires {\phi_{pre}};~\ensures {\phi_{post}};}~\{ {\_} \}}}\\
        {\Gamma} \vdash {{x}} : {T_r}\\{\Gamma} \vdash {{z'}} : {T_p}\\
        {\phi} \implies {{({{y}} \neq {{\vnull}})} * {{\phi_p}}}\\
        \phi_r = \phi / \phi_p / x\\
        x \neq y \wedge x \neq z'\\
        {\phi_p} = {{\phi_{pre}}[{y}, {z'} / {\xthis}, {{z}}]}\\
        {\phi_q} = {{\phi_{post}}[{y}, {z'}, {x} / {\xthis}, {{z}}, {\xresult}]}}
    {\Gamma \hoare {\phi} {{x} := {y}.{m}({z'})} {{\phi_q} * {\phi_r}}}
\end{mathpar}

\begin{mathpar}
    \inferrule* [Right=GHAppD]
    {{\Gamma} \vdash {{y}} : {{C}}\\
        {\mmethod({C}, {m})} = {{{T_r}~{m}({T_p}~{z})~{\requires {\grad{\phi_{pre}}};~\ensures {\grad{\phi_{post}}};}~\{ {\_} \}}}\\
        {\Gamma} \vdash {{x}} : {T_r}\\{\Gamma} \vdash {{z'}} : {T_p}\\
        {\grad{\phi}} \grad{\implies} {{({{y}} \neq {{\vnull}})} * {{\phi_p}}}\\
        \grad{\phi_r} = \grad{\phi} /_{y : C, z' : T_p, x : T_r} \grad{\phi_p} / x\\
        x \neq y \wedge x \neq z'\\
        \grad{\phi_p} = {{\grad{\phi_{pre}}}[{y}, {z'} / {\xthis}, {{z}}]}\\
        \grad{\phi_q} = {{\grad{\phi_{post}}}[{y}, {z'}, {x} / {\xthis}, {{z}}, {\xresult}]}}
    {\Gamma~ \ghoare {\grad{\phi}} {{x} := {y}.{m}({z'})} {\grad{\phi_q} * \grad{\phi_r}}}
\end{mathpar}


\section{Dynamic semantics}
\newcommand{\evalex}[4]{#1,#2 \vdash #3 \Downarrow #4}
\newcommand{\evale}[2]{H,\rho \vdash #1 \Downarrow #2}
\subsection{Expressions ($\evale {e} {v}$)}

\begin{mathpar}
\inferrule* [Right=EEVar]
{~}
{\evale {x} {\rho(x)}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=EEValue]
{~}
{\evale {v} {v}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=EEAcc]
{\evale {e} {o}}
{\evale {e.f} {H(o)(f)}}
\end{mathpar}

\newcommand{\evalphix}[4]{#1,#2,#3 \vDash #4}
\newcommand{\evalphi}{\evalphix H \rho A}
\newcommand{\valphi}[1]{\llbracket #1 \rrbracket}
\subsection{Formulas ($\evalphi \phi$)}
\input{dynamicFormula}

\begin{mathpar}
\inferrule* [Right=EASepOp]
{
A_1 = A \backslash A_2 \\
\evalphix H \rho {A_1} {\phi_1} \\
\evalphix H \rho {A_2} {\phi_2}
}
{\evalphi {\phi_1 * \phi_2}}
\end{mathpar}

We give a denotational semantics of formulas as $\valphi {\phi} = \{~ (H,\rho,A) ~|~ \evalphi {\phi} ~\}$

Note: $\phi \text{ satisfiable} \iff \valphi {\phi} \neq \emptyset$

\subsubsection{Implication ($\phi_1 \implies \phi_2$)}
%\begin{equation*}
%\phi_1 \implies \phi_2
%\quad\quad \iff \quad\quad
%\valphi {\phi_1} \subseteq \valphi {\phi_2}
%\end{equation*}

\begin{equation*}
\phi_1 \implies \phi_2
\quad\quad \iff \quad\quad
\forall H, \rho, A: \evalphi \phi_1 \implies \evalphi \phi_2
\end{equation*}
Drawn from def. of entailment in ``A Formal Semantics for Isorecursive and Equirecursive State Abstractions''.

\subsubsection{Implying inequality}
\begin{align*}
\\   & \phi * (e_1 = e_1) * (e_2 = e_2) \implies (e_1 \neq e_2)
\\ =~& \forall H, \rho, A:~ \evalphi \phi * (e_1 = e_1) * (e_2 = e_2) \implies \evalphi (e_1 \neq e_2)
\\ =~& \forall H, \rho, A:~  (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \implies (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge (v_1 \neq v2))
\\ =~& \forall H, \rho, A, v_1, v_2:~  (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \implies (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge (v_1 \neq v2))
\\ =~& \forall H, \rho, A, v_1, v_2:~  (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \implies (v_1 \neq v2)
\\ =~& \forall H, \rho, A, v_1, v_2:~  \neg (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \vee (v_1 \neq v2)
\\ =~& \forall H, \rho, A, v_1, v_2:~  \neg (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi \wedge (v_1 = v2))
\\ =~& \forall H, \rho, A:~ \neg (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi \wedge (v_1 = v2))
\\ =~& \forall H, \rho, A:~ \neg (\evalphi \phi \wedge \evalphi (e_1 = e_2))
\\ =~& \forall H, \rho, A:~ \neg \evalphi \phi * (e_1 = e_2)
\\ =~& \neg \text{sat~}(\phi * (e_1 = e_2))
\end{align*}

\subsection{Footprint ($\dynamicFP {H} {\rho} {\phi} = A_d$)}
\begin{align*}
 &\dynamicFP {H} {\rho} {\true}    		&&= \emptyset
\\ &\dynamicFP {H} {\rho} {e_1 = e_2}     	&&= \emptyset
\\ &\dynamicFP {H} {\rho} {e_1 \neq e_2}  	&&= \emptyset
\\ &\dynamicFP {H} {\rho} {\acc(x.f)} 		&&= \{(o,f)\} \text{ where } \evale x o
\\ &\dynamicFP {H} {\rho} {\phi_1 * \phi_2} &&= \dynamicFP {H} {\rho} {\phi_1} \cup \dynamicFP {H} {\rho} {\phi_2}
\end{align*}

\newcommand{\dType}[4]{#1, #2 \vdash #3 : #4}

\newcommand{\sstepGeneric}[5]{({#1}, {#2}) \rightarrow^{#3} ({#4}, {#5})}
\newcommand{\sstep}[4]{\sstepGeneric {#1} {#2} {} {#3} {#4}}
\newcommand{\sstepM}[4]{\sstepGeneric {#1} {#2} * {#3} {#4}} 
\newcommand{\sstepWS}[4]{\sstepGeneric {#1} {{#2} \cdot S} {} {#3} {{#4} \cdot S}}
\newcommand{\sstepWSX}[8]{\sstepGeneric {#1} {({#2},{#3},{#4}) \cdot S} {} {#5} {({#6},{#7},{#8}) \cdot S}}

\newcommand{\Tfs}{\overline{T}~\overline{f}}
\subsection{Small-step ($\sstep H S H S$)}
\input{dynamicSemantics}
%\input{dynamicSemanticsX}

\section{Gradualization}
\subsection{Syntax}
\subsubsection{Gradual formula}
\begin{align*}
&\grad{\phi} \quad ::= \quad \phi ~|~ \withqm{\phi}
\end{align*}

Note: consider $?$ in other positions as ``self-framing delimiter'', but with semantically identical meaning.

As long as $?$ is only legal in the front though: $\phi_1 * \grad{\phi_2}$ propagates the $?$ to the very left in case $\grad{\phi_2}$ contains one.

\subsubsection{Self-framed and satisfiable formula}
\begin{align*}
&\hat{\phi} \quad \in \quad \{~ \phi ~|~ \sfrmphi \phi \wedge \text{sat~} \phi ~\}
\end{align*}

\subsection{Concretization}
\begin{align*}
&\gamma(\hat{\phi}) ~&&= \{~ \hat{\phi} ~\} \\
&\gamma(?\:*\:\phi') ~&&= \{~ \hat{\phi} ~|~ \hat{\phi} \implies \phi' ~\} \text{~~if $\phi'$ satisfiable} \\
&\gamma(\phi) \text{ undefined otherwise} \\
~\\
&\grad{\phi_1} \sqsubseteq \grad{\phi_2} \quad:\iff\quad \gamma(\grad{\phi_1}) \subseteq \gamma(\grad{\phi_2})
\end{align*}



\subsection{Abstraction}
\begin{align*}
&\alpha(\overline{\phi}) &&= \min_{\sqsubseteq} {\{~ \grad{\phi} ~|~ \overline{\phi} \subseteq \gamma(\grad{\phi}) ~\}}\\
\end{align*}

Proved:
\begin{itemize}
	\item partial function
	\item sound
	\item optimal
	\item $\alpha(\gamma(\grad{\phi})) = \grad{\phi}$
\end{itemize}

%\subsection{$(\phi, \implies)$ is semilattice}
%According to the definition of $\implies$ via $\subseteq$, we define
%\begin{align*}
%\phi_a \sqcap \phi_b = \phi_c   \quad :\iff \quad   \valphi{\phi_a} \cap \valphi{\phi_b} = \valphi{\phi_c}
%\end{align*}

%The question is, whether such $\phi_c$ always exists.



%\subsection{Concretization D (as in denotational)}
%\begin{align*}
%&\gamma(\phi) ~&&= \{~ \valphi{\phi} ~\} \\
%&\gamma(\withqm{\phi}) ~&&= \{~ \valphi{\phi\:*\:\phi_x} ~|~ \exists \phi_x : \valphi{\phi\:*\:\phi_x} \neq \emptyset ~\} \\
%& ~&&= \{~ \valphi{\phi'} ~|~ \exists \phi' : \emptyset \neq \valphi{\phi'} \wedge \phi' \implies \phi ~\} \\
%& ~&&= \{~ \valphi{\phi'} ~|~ \exists \phi' : \emptyset \neq \valphi{\phi'} \wedge \valphi{\phi'} \subseteq \valphi{\phi} ~\} \\
%\end{align*}

\subsection{Gradual Lifting}
\subsubsection{Self framing}
\begin{mathpar}
\inferrule* [Right=GSfrmNonGrad]
{A \sfrmphi \phi}
{A ~\grad{\sfrmphi}~ \phi}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GSfrmGrad]
{~}
{A ~\grad{\sfrmphi}~ ?\:*\:\phi}
\end{mathpar}

\subsubsection{Implication}
\begin{mathpar}
\inferrule* [Right=GImplNonGrad]
{\phi_1 \implies \phi_2}
{\phi_1 ~\grad{\implies}~ \grad{\phi_2}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GImplGrad]
{\hat{\phi_m} \implies \phi_2 \\
 \hat{\phi_m} \implies \phi_1}
{?\:*\:\phi_1 ~\grad{\implies}~ \grad{\phi_2}}
\end{mathpar}

%Remark: Whether second argument is gradual or not seems to be irrelevant. Interestingly, all of our later uses will also pass non-gradual formulas as second argument. Maybe the natural lifting of this predicate should only lift on first argument in the first place?

$\hat{\phi_m}$ is evidence! \\


\textbf{Consistent transitivity}

While $\implies$ is transitive, $\grad{\implies}$ is generally not.

But maybe not even necessary with smarter hoare rules?

%\subsubsection{Free Variable}
%\begin{mathpar}
%\inferrule* [Right=GNotInFV]
%{x \not\in FV(\phi)}
%{x \not\in FV(\grad{\phi})}
%\end{mathpar}

\subsubsection{Equality}
\begin{mathpar}
\inferrule* [Right=GEqStatic]
{\phi_1 = \phi_2}
{\phi_1 \approx \phi_2}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GEqGradual]
{
\text{at least one of $\grad{\phi_1}$ or $\grad{\phi_2}$ contains $?$}
\\\\
\grad{\phi_1} \grad{\implies} \grad{\phi_2} \\
\grad{\phi_2} \grad{\implies} \grad{\phi_1}
}
{\grad{\phi_1} \approx \grad{\phi_2}}
\end{mathpar}

\subsubsection{Append}
\begin{align*}
&\text{by definition:}\\
&\grad{\phi} ~\grad{*}~ \phi_p = \alpha(\gamma(\grad{\phi}) \overline{*} \phi_p)
&~\\\\
&\text{equivalent to:}\\
&\grad{\phi} ~\grad{*}~ \phi_p = \grad{\phi} * \phi_p
      && \text{if~} \forall \hat{\phi_1}, (\hat{\phi_1} \implies \phi * \phi_p) \implies 
                    \exists \hat{\phi_2}, (\hat{\phi_2} \implies \phi \wedge \hat{\phi_1} \implies \hat{\phi_2} * \phi_p) \\
&~
      && \text{if~} \forall \hat{\phi_1} \in \gamma(\grad{\phi} * \phi_p), 
                    \exists \hat{\phi_2} \in \gamma(\grad{\phi}), \hat{\phi_1} \implies \hat{\phi_2} * \phi_p \\
&\grad{\phi} ~\grad{*}~ \phi_p \textit{~undefined}
      && \text{otherwise}
\end{align*}
% (forall p'',(good p'' /\ phiImplies p'' (snd gp1 ++ p)) ->
% exists p' , good p'  /\ phiImplies p'  (snd gp1) /\ phiImplies p'' (p' ++ p))


\subsection{Gradual Hoare: minimal static rule approach}

\newcommand{\imp}[1]{\textcolor{red}{#1}}
Example:

\begin{mathpar}
\inferrule* [Right=GHVarAssign]
{
\imp{\epsilon \vdash\,} \grad{\phi} \grad{\implies} \grad{\phi'}
\\\imp{\emptyset \sfrmphi \grad{\phi'}}
\\\imp{x \not \in FV(\grad{\phi'})}
\\x \not \in FV(e)
\\\imp{\epsilon \vdash\,} \grad{\phi} \vdash x : T
\\\imp{\epsilon \vdash\,} \grad{\phi} \vdash e : T
\\\imp{\epsilon \vdash\,} \staticFP {\grad{\phi'}} \sfrme e
}
{\hoare {\grad{\phi}} {x := e} {\grad{\phi'} * (x = e)}}
\end{mathpar}

Collapsing (hidden) gradual implications into a single one:
\begin{mathpar}
\inferrule* [Right=GHVarAssign]
{
\imp{\epsilon \vdash\,} \grad{\phi} \grad{\implies} (x : T) * \hasTypeFormula e T C * \grad{\phi'}
\\\imp{\emptyset \sfrmphi \hasTypeFormula e T C * \grad{\phi'}}
\\\imp{x \not \in FV(\grad{\phi'})}
\\x \not \in FV(e)
\\\hasTypePremise e T C
}
{\hoare {\grad{\phi}} {x := e} {\hasTypeFormula e T C * \grad{\phi'} * (x = e)}}
\end{mathpar}

When shifting implication responsibility to GHSec:
\begin{mathpar}
\inferrule* [Right=GHVarAssign]
{
\imp{x \not \in FV(\grad{\phi'})}
\\x \not \in FV(e)
\\\hasTypePremise e T C
}
{\hoare {(x : T) * \hasTypeFormula e T C * \grad{\phi'}} {x := e} {\hasTypeFormula e T C * \grad{\phi'} * (x = e)}}
\end{mathpar}

Example derivation:
\begin{align*}
\\& \{(x : T) * \textcolor{blue}{(y : C) * \acc(y.a) * \acc(y.a.b) * \acc(y.a.b.c)} * \grad{\phi'}\}
\\& \{(x : T) * \textcolor{blue}{\hasTypeFormula {y.a.b.c} T C} * \grad{\phi'}\}
\\& x := y.a.b.c;	\quad\quad\quad\quad\textcolor{gray}{\parbox{14cm}{
\textcolor{red}{$x \not \in FV(\grad{\phi'})$}\\
$x \not \in FV(y.a.b.c)$\\
$\hasTypePremise {y.a.b.c} T C =
~\vdash C_y = C 	\,\,\wedge 
~\vdash C_y.a : C_a \,\,\wedge
~\vdash C_a.b : C_b \,\,\wedge
~\vdash C_b.c : T$}}
\\& \{\textcolor{blue}{\hasTypeFormula {y.a.b.c} T C} * \grad{\phi'} * (x = y.a.b.c)\}
\\& \{\textcolor{blue}{(y : C) * \acc(y.a) * \acc(y.a.b) * \acc(y.a.b.c)} * \grad{\phi'} * (x = y.a.b.c)\}
\end{align*}

\subsubsection{GHFieldAssign}

\begin{mathpar}
\inferrule* [Right=GHFieldAssign]
{
\sfrmphi \phi \\
\vdash C.f : T \\
\grad{\phi_1} \approx {(x : C) * (y : T) * (x \neq \vnull) * \phi * \acc(x.f)} \\
\grad{\phi_2} \approx {(x : C) * \acc(x.f) * (x \neq \vnull) * (x.f = y) * \phi}
}
{\ghoare
{\grad{\phi_1}} 
{x.f := y} 
{\grad{\phi_2}}}
\end{mathpar}

\subsubsection{GHSec - sound but obviously not complete!}

\begin{mathpar}
\inferrule* [Right=GHSec]
{
 \ghoare {\grad{\phi_p}} {s_1} {\grad{\phi_{q1}}} \\ 
 \phi_{q1} \implies \phi_{q2} \\
 \emptyset \sfrmphi \phi_{q2} \\
 \ghoare {\phi_{q2}} {s_2} {\grad{\phi_r}}
}
{\ghoare {\grad{\phi_p}} {s_1;s_2} {\grad{\phi_r}}}
\end{mathpar}

\subsection{Gradual Hoare: minimal HSec approach (implications per rule)}

\begin{mathpar}
\inferrule* [Right=HFieldAssign]
{
\sfrmphi \phi \\
\vdash C.f : T \\\\
\phi_1 \implies {(x : C) * (y : T) * \phi * \acc(x.f)} \\
\phi_2 = {(x : C) * \acc(x.f) * (x.f = y) * \phi}
}
{\hoare
{\phi_1}
{x.f := y}
{\phi_2}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GHFieldAssign]
{
\sfrmphi \phi \\
\vdash C.f : T \\\\
\grad{\phi_1} \grad{\implies} {(x : C) * (y : T) * \phi * \acc(x.f)} \\
\grad{\phi_2} \approx {(x : C) * \acc(x.f) * (x.f = y) * \phi}
}
{\ghoare
{\grad{\phi_1}}
{x.f := y}
{\grad{\phi_2}}}
\end{mathpar}

Note: With this alternative rule design $\grad{\implies}$ is consistently used with static formulas as second argument. 
This plays nicely with the fact that $\grad{\implies}$ does not care about the gradualness of that argument.
Might make sense to define lifting of $\implies$ as lifting on only the first parameter in the first place.\\

\textbf{Minimum runtime checks}: For $\grad{\phi_1} \grad{\implies} \grad{\phi_2}$ to hold at runtime, practically just $\phi_2$ needs to hold. So that would be a valid assertion to check. Yet, we know statically that $\phi_1$ holds, so we can remove everything from the runtime check that is implied by $\phi_1$.
So in a sense, we only need to check $\phi_2 \backslash \phi_1$ at runtime (the operator can be an approximation).


\subsection{Gradual Hoare: deterministic approach}
\subsubsection{HFieldAssign}

\begin{mathpar}
\inferrule* [Right=HFieldAssign]
{
\vdash C.f : T \\\\
\phi_1 \implies {(x : C) * (y : T) * \acc(x.f)} \\
\phi_2 = {(x : C) * \acc(x.f) * (x.f = y) * \phi_1[\textbf{w/o } \acc(x.f)]}
}
{\hoare
{\phi_1}
{x.f := y}
{\phi_2}}
\end{mathpar}

Note: $\phi[\textbf{w/o } \acc(x.f)]$ removes $\acc(x.f)$ and all uses of $x.f$ from $\phi$. The result is self-framed given that $\phi$ is.\\

\textbf{Attention}:
This version is weaker than the other (pairwise equivalent) versions of HFieldAssign!

Explanation: Above operator may remove more information than necessary from $\phi$.

Example:
\begin{itemize}
\item Given: $\phi_1 = \acc(x.f) * (x.f = a) * (x.f = b)$
\item Goal: $\phi_2 \implies (a = b)$
\item \textbf{not provable} with this deterministic version of HFieldAssign
\item \textbf{provable} with all other versions
\end{itemize}

Probably it's possible to apply the operator without information loss after expanding formula using equalities (transitive hull).

\subsubsection{GHFieldAssign}
(= gradual lifting of GHFieldAssign as function)

\begin{mathpar}
\inferrule* [Right=GHFieldAssign]
{
\grad{\phi_2} = \alpha(\{
\phi_2
~|~
\phi_1 \in \gamma(\grad{\phi_1})
~\wedge~
\hoare
{\phi_1}
{x.f := y}
{\phi_2}
~
\})
}
{
\ghoare
{\grad{\phi_1}}
{x.f := y}
{\grad{\phi_2}}
}
\end{mathpar}

Which should be equivalent to this:
\begin{mathpar}
\inferrule* [Right=GHFA1]
{
\vdash C.f : T \\\\
\phi_1 \implies {(x : C) * (y : T) * \acc(x.f)} \\\\
\phi_2 = {(x : C) * (y : T) * \acc(x.f) * (x.f = y) * \phi_1[\textbf{w/o } \acc(x.f)]}
}
{\ghoare
{\phi_1}
{x.f := y}
{\phi_2}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GHFA2]
{
\vdash C.f : T \\\\
\withqm{\phi_1} \grad{\implies}_{\phi_m} {(x : C) * \acc(x.f)} \\\\
\phi_2 = {(x : C) * \acc(x.f) * (x.f = y) * \phi_m[\textbf{w/o } \acc(x.f)]}
}
{\ghoare
{\withqm{\phi_1}}
{x.f := y}
{\withqm{\phi_2}}}
\end{mathpar}

Which should be summarizable as this:
\begin{mathpar}
\inferrule* [Right=GHFA]
{
\vdash C.f : T \\\\
\grad{\phi_1} \grad{\implies}_{\grad{\phi_m}} {(x : C) * (y : T) * \acc(x.f)} \\\\
\grad{\phi_2} = {(x : C) * \acc(x.f) * (x.f = y) * \grad{\phi_m}[\textbf{w/o } \acc(x.f)]}
}
{\ghoare
{\grad{\phi_1}}
{x.f := y}
{\grad{\phi_2}}}
\end{mathpar}

Which for well-formed programs is equivalent to:
\begin{mathpar}
\inferrule* [Right=GHFA]
{
\vdash C.f : T \\\\
\phi_1 \implies {(x : C) * (y : T)} \\
\grad{\phi_1} \grad{\implies} {\acc(x.f)} \\\\
\grad{\phi_2} = {(x : C) * (y : T) * \acc(x.f) * (x.f = y) * \grad{\phi_1}[\textbf{w/o } \acc(x.f)]}
}
{\ghoare
{\grad{\phi_1}}
{x.f := y}
{\grad{\phi_2}}}
\end{mathpar}

Observations:
\begin{itemize}
\item $\grad{\phi_m}$ is the interior (first argument) of the implication, effectively the meet of first and second argument.
\item for the gradual rules to work, the \textbf{w/o}-operator \textbf{must} be implemented with minimal information loss
\end{itemize}


\subsection{Theorems}
\subsubsection{Soundness of $\alpha$}
\begin{align*}
&\forall \overline{\phi} : \overline{\phi} \subseteq \gamma(\alpha(\overline{\phi}))
\end{align*}
\subsubsection{Optimality of $\alpha$}
\begin{align*}
&\forall \overline{\phi}, \grad{\phi} : \overline{\phi} \subseteq \gamma(\grad{\phi}) \implies  \gamma(\alpha(\overline{\phi}))\subseteq
\gamma(\grad{\phi}) 
\end{align*}

\section{Theorems}
\subsection{Invariant $invariant(H, \rho, A_d, \phi)$}

\subsubsection{Phi valid}
\begin{align*}
    \sfrmphi {\phi}
\end{align*}

\subsubsection{Phi holds}
\begin{align*}
    \evalphix {H} {\rho} {A_d} {\phi}
\end{align*}

\subsubsection{Types preserved}
\begin{align*}
    \forall e, T : \sType {\phi} {e} {T}& \\
    \implies \dType {H} {\rho} {e} {T}&
\end{align*}

\subsubsection{Heap consistent}
\begin{align*}
\forall o, C, \mu, f, T :&~ 
H(o) = (C, \mu) \\
\implies&~ 
\texttt{fieldType}(C,f) = T \\
\implies&~
\dType {H} {\rho} {\mu(f)} {T}
\end{align*}

\subsubsection{Heap not total}
\begin{align*}
\exists o_{min} :&\\
\forall o \ge o_{min} :&~ o \not \in \texttt{dom}(H) \\
\wedge&~ \forall f, (o, f) \not \in A
\end{align*}

\subsection{Soundness}
\subsubsection{Progress}
\begin{align*}
\forall~ ... &:~~ \hoare {\phi_1} {s'} {\phi_2} 
\\ &\implies invariant(H_1, \rho_1, A_1, \phi_1)
\\ &\implies \exists H_2, \rho_2, A_2 : (H_1, (\rho_1, A_1, s' ; \overline{s}) \cdot S)
							\rightarrow^* (H_2, (\rho_2, A_2, \overline{s}) \cdot S)
\end{align*}

\subsubsection{Preservation}
\begin{align*}
\forall~ ... &:~~ \hoare {\phi_1} {s'} {\phi_2} 
\\ &\implies invariant(H_1, \rho_1, A_1, \phi_1)
\\ &\implies (H_1, (\rho_1, A_1, s' ; \overline{s}) \cdot S)
  \rightarrow^* (H_2, (\rho_2, A_2, \overline{s}) \cdot S)
\\ &\implies invariant(H_2, \rho_2, A_2, \phi_2)
\end{align*}

\end{document}