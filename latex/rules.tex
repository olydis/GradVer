\documentclass[11pt,a4paper]{article}
%twocolumn
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{syntax}
\usepackage{lscape}
\usepackage{stmaryrd}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{mathpartir}
%\usepackage{fontspec}
%\usepackage[pdftex]{graphicx}

%\usetikzlibrary{positioning,calc}

\DeclareMathSymbol{\mlq}{\mathord}{operators}{``}
\DeclareMathSymbol{\mrq}{\mathord}{operators}{`'}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}

%\setmonofont{lmmono8}
%\setmainfont[Mapping=olydis]{Heuristica}
\usepackage{newunicodechar}
\newunicodechar{≠}{=\llap{/}}
\newunicodechar{≔}{:\raisebox{-0.18ex}[\height][\depth]{=}}

\def\extraVskip{3pt}
\newenvironment{scprooftree}[1]%
  {\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
  {\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }

\makeatletter
\providecommand{\bigsqcap}{%
  \mathop{%
    \mathpalette\@updown\bigsqcup
  }%
}
\newcommand*{\@updown}[2]{%
  \rotatebox[origin=c]{180}{$\m@th#1#2$}%
}
\makeatother

\setlength{\parindent}{0cm}

%\includeonly{staticSemanticsDetermGrad}
\begin{document}
\pagenumbering{arabic}


\newcommand{\hasTypePremise}[3]{[#1 : #2]_{#3}}
\newcommand{\hasTypeFormula}[3]{{\llbracket #1 : #2\rrbracket}_{#3}}
\newcommand{\accFor}[1]{\llbracket #1 \rrbracket}

\newcommand{\Heap}{H}

\newcommand{\sfrme}{\ensuremath{\vdash_\texttt{sfrm}}\,}
\newcommand{\sfrmphi}{\ensuremath{\vdash_\texttt{sfrm}}\,}

%DEPRECATED
\newcommand{\true}{\ensuremath{\texttt{true}}}
\newcommand{\vnull}{\ensuremath{\texttt{null}}}
\newcommand{\Tint}{\ensuremath{\texttt{int}}}
\newcommand{\xresult}{\ensuremath{\texttt{result}}}
\newcommand{\xthis}{\ensuremath{\texttt{this}}}
\newcommand{\new}{\ensuremath{\texttt{new}~}}
\newcommand{\assert}{\ensuremath{\texttt{assert}~}}
\newcommand{\release}{\ensuremath{\texttt{release}~}}
\newcommand{\return}{\ensuremath{\texttt{return}~}}
\newcommand{\acc}{\ensuremath{\texttt{acc}}}
%DEPRECATED

\newcommand{\fields}{\ensuremath{\textsf{fields}}}
\newcommand{\mpre}{\ensuremath{\textsf{mpre}}}
\newcommand{\mpost}{\ensuremath{\textsf{mpost}}}
\newcommand{\mbody}{\ensuremath{\textsf{mbody}}}
\newcommand{\mparam}{\ensuremath{\textsf{mparam}}}
\newcommand{\mrettype}{\ensuremath{\textsf{mrettype}}}
\newcommand{\mmethod}{\ensuremath{\textsf{mmethod}}}

%\newcommand{\staticFP}[1]{\ensuremath{\texttt{static-footprint}(#1)}}
%\newcommand{\dynamicFP}[3]{\ensuremath{\texttt{footprint}_{#1,#2}(#3)}}

\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
\newcommand{\staticFP}[1]{\ensuremath{\floor{#1}}}
\newcommand{\dynamicFP}[3]{\ensuremath{\floor{#3}_{#1,#2}}}

\newcommand{\rlabel}[1]{\RightLabel{\quad #1}}
\newcommand{\dom}{\ensuremath{\text{dom}}}

\newcommand{\class}{\ensuremath{\texttt{class}~}}
\newcommand{\requires}{\ensuremath{\texttt{requires}~}}
\newcommand{\ensures}{\ensuremath{\texttt{ensures}~}}

\newcommand{\grad}[1]{\widetilde{#1}}
\newcommand{\qm}{\ttt{?}}
\newcommand{\withqm}[1]{\ttt{\qm\:*\:$#1$}}

\newcommand{\hoare}[3]{\vdash\{#1\}#2\{#3\}}
\newcommand{\ghoare}[3]{\grad{\vdash}\{#1\}#2\{#3\}}

\newcommand{\hsc}{~\hat{*}~}
\newcommand{\gsc}{~\grad{*}~}
\newcommand{\wo}[2]{#1\textbf{[w/o~}#2\textbf{]}} 
\newcommand{\imp}{\text{imp}}

% typewriter stuff
\newcommand{\ttt}{\texttt}

% expressions
\newcommand{\ev}[1]{\ttt{#1}}
\newcommand{\ex}[1]{\ttt{#1}}
\newcommand{\edot}[2]{\ttt{#1.#2}}
% formulas
\newcommand{\phiCons}[2]{\ttt{#1\:*\:#2}}
\newcommand{\phiFalse}[0]{\ttt{false}}
\newcommand{\phiTrue}[0]{\ttt{true}}
\newcommand{\phiEq}[2]{\ttt{(#1 = #2)}}
\newcommand{\phiNeq}[2]{\ttt{(#1 ≠ #2)}}
\newcommand{\phiAcc}[2]{\ttt{acc(#1.#2)}}
% statements
\newcommand{\sMemberSet}[3]{\ttt{#1.#2 ≔ #3;}}
\newcommand{\sAssign}[2]{\ttt{#1 ≔ #2;}}
\newcommand{\sAlloc}[2]{\ttt{#1 ≔ \new #2;}}
\newcommand{\sCall}[4]{\ttt{#1 ≔ #2.#3(#4);}}
\newcommand{\sReturn}[1]{\ttt{return #1;}}
\newcommand{\sAssert}[1]{\ttt{assert #1;}}
\newcommand{\sRelease}[1]{\ttt{release #1;}}
\newcommand{\sDeclare}[2]{\ttt{#1~#2;}}

% structure
\newcommand{\method}[6]{\ttt{#1~#2(#3~#4)~#5~\{ #6 \}}}

\section{Syntax}
\begin{align*}
\\ &program    	&&::= \ttt{$\overline{cls}$~$\overline{s}$}
\\ &cls    		&&::= \ttt{\class $C$~\{ $\overline{field}$~$\overline{method}$ \}}
\\ &field    	&&::= \ttt{$T$~$f$;}
\\ &method		&&::= \method {$T$} {$m$} {$T$} {$x$} {$contract$} {$\overline{s}$}
\\ &contract	&&::= \ttt{requires $\phi$;~ensures $\phi$;}
\\ &T			&&::= \Tint ~|~ C
\\ &s			&&::= \sMemberSet {$x$} {$f$} {$y$}
				  ~|~ \sAssign {$x$} {$e$}
				  ~|~ \sAlloc {$x$} {$C$}
				  ~|~ \sCall {$x$} {$y$} {$m$} {$z$}
\\ & &&
				  ~|~ \sReturn {$x$}
				  ~|~ \sAssert {$\phi$}
				  ~|~ \sRelease {$\phi$}
				  ~|~ \sDeclare {$T$} {$x$}
\\ &\phi		&&::= \phiTrue
                  ~|~ \phiEq {$e$} {$e$}
				  ~|~ \phiNeq {$e$} {$e$}
				  ~|~ \phiAcc {$e$} {$f$}
				  ~|~ \phiCons {$\phi$} {$\phi$}
\\ &e			&&::= \ev{$v$}
				  ~|~ \ex{$x$}
				  ~|~ \edot{$e$}{$f$}
\\ &x			&&::= \xthis ~|~ \xresult ~|~ \langle other \rangle
\\ &v			&&::= o ~|~ n ~|~ \vnull
\\ &n			&&\in~~ \mathbb{Z}
\\				  
\\ &H			&&\in~~ (o \rightharpoonup (C,\overline{(f \rightharpoonup v)}))
\\ &\rho		&&\in~~ (x \rightharpoonup v)
\\ &\Gamma		&&\in~~ (x \rightharpoonup T)
\\ &A_s			&&::= \overline{(e, f)}
\\ &A_d			&&::= \overline{(o, f)}
\\ &S			&&::= (\rho, A_d, \overline{s}) \cdot S ~|~ nil
\end{align*}

\newcommand{\OK}{~\textsf{OK}}
\newcommand{\OKinC}{~\textsf{OK in}~C}
\section{Assumptions}
All the rules in the following sections are implicitly parameterized over a $program p$ that is well-formed.

\subsubsection{Well-formed program ($program \OK$)}
\begin{mathpar}
\inferrule* [Right=OKProgram]
{
\overline{cls_i \OK}
}
{(\overline{cls_i}~\overline{s}) \OK}
\end{mathpar}

\subsubsection{Well-formed class ($cls \OK$)}
\begin{mathpar}
\inferrule* [Right=OKClass]
{
\text{unique $field$-names} \\
\text{unique $method$-names} \\
\overline{method_i \OKinC}
}
{(\class C~\{\overline{field_i}~\overline{method_i}\}) \OK}
\end{mathpar}

\subsubsection{Well-formed method ($method \OKinC$)}
\begin{mathpar}
\inferrule* [Right=OKMethod]
{
FV(\phi_1) \subseteq \{ x, \xthis \} \\
FV(\phi_2) \subseteq \{ x, \xthis, \xresult \} \\
x : T_x, \xthis : C, \xresult : T_m \hoare {\phi_1} {\overline{s}} {\phi_2} \\
\emptyset \sfrmphi {\phi_1} \\
\emptyset \sfrmphi {\phi_2} \\
\overline{\neg \textsf{writesTo}(s_i, x)}
}
{(\method {$T_m$} {$m$} {$T_x$} {$x$} {\requires $\phi_1$;~\ensures $\phi_2$;} {$\overline{s}$}) \OKinC}
\end{mathpar}


\section{Static semantics}
\subsection{Expressions ($A_s \sfrme e$)}
\input{staticExpression}

\subsection{Formulas ($A_s \sfrme \phi$)}
\input{staticFormula}

\begin{mathpar}
\inferrule* [Right=WFSepOp]
{
A_s \sfrmphi \phi_1 \\ 
A_s \cup \staticFP {\phi_1} \sfrmphi \phi_2
}
{A_s \sfrmphi \phi_1 * \phi_2}
\end{mathpar}

\subsubsection{Implication ($\phi_1 \dot{\implies} \phi_2$)}
Conservative approx. of $\phi_1 \implies \phi_2$.

\subsection{Footprint ($\staticFP {\phi} = A_s$)}
\begin{align*}
 &\staticFP {\phiTrue}    		                &&= \emptyset
\\ &\staticFP {\phiEq {$e_1$} {$e_2$}}      	&&= \emptyset
\\ &\staticFP {\phiNeq {$e_1$} {$e_2$}}      	&&= \emptyset
\\ &\staticFP {\phiAcc {$e$} {$f$}} 	    	&&= \{(e,f)\}
\\ &\staticFP {\phiCons {$\phi_1$} {$\phi_2$}} 	&&= \staticFP {\phi_1} \cup \staticFP {\phi_2}
\end{align*}

\newcommand{\sType}[3]{#1 \vdash #2 : #3}
\subsection{Type ($\sType {\Gamma} {e} {T}$)}
%\begin{mathpar}
%\inferrule* [Right=STValue]
%{~}
%{\sType {\phi} {\null} {T}}
%\end{mathpar}
\begin{mathpar}
\inferrule* [Right=STValNum]
{~}
{\sType {\Gamma} {n} {\Tint}}
\end{mathpar}
\begin{mathpar}
\inferrule* [Right=STValNull]
{~}
{\sType {\Gamma} {\vnull} {T}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=STVar]
{\Gamma(x) = T}
{\sType {\Gamma} {x} {T}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=STField]
{ \sType {\Gamma} {e} {C}
\\ \vdash C.f : T}
{\sType {\Gamma} {\edot{$e$}{$f$}} {T}}
\end{mathpar}

\subsection{Hoare ($\Gamma \hoare {\phi} {\overline s} {\phi}$)}
\input{staticSemantics}

\subsubsection{Notation}
\input{staticSemanticsNotation}

\subsubsection{Deterministic}
\input{staticSemanticsDeterm}

\subsubsection{Gradual}
\input{staticSemanticsDetermGrad}

\section{Dynamic semantics}
\newcommand{\evalex}[4]{#1,#2 \vdash #3 \Downarrow #4}
\newcommand{\evale}[2]{H,\rho \vdash #1 \Downarrow #2}
\subsection{Expressions ($\evale {e} {v}$)}

\begin{mathpar}
\inferrule* [Right=EEVar]
{~}
{\evale {x} {\rho(x)}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=EEValue]
{~}
{\evale {v} {v}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=EEAcc]
{\evale {e} {o}}
{\evale {e.f} {H(o)(f)}}
\end{mathpar}

\newcommand{\evalphix}[4]{#1,#2,#3 \vDash #4}
\newcommand{\evalphi}{\evalphix H \rho A}
\newcommand{\valphi}[1]{\llbracket #1 \rrbracket}
\subsection{Formulas ($\evalphi \phi$)}
\input{dynamicFormula}

\begin{mathpar}
\inferrule* [Right=EASepOp]
{
A_1 = A \backslash A_2 \\
\evalphix H \rho {A_1} {\phi_1} \\
\evalphix H \rho {A_2} {\phi_2}
}
{\evalphi {\phiCons {$\phi_1$} {$\phi_2$}}}
\end{mathpar}

We give a denotational semantics of formulas as $\valphi {\phi} = \{~ (H,\rho,A) ~|~ \evalphi {\phi} ~\}$

Note: $\phi \text{ satisfiable} \iff \valphi {\phi} \neq \emptyset$

\subsubsection{Implication ($\phi_1 \implies \phi_2$)}
%\begin{equation*}
%\phi_1 \implies \phi_2
%\quad\quad \iff \quad\quad
%\valphi {\phi_1} \subseteq \valphi {\phi_2}
%\end{equation*}

\begin{equation*}
\phi_1 \implies \phi_2
\quad\quad \iff \quad\quad
\forall H, \rho, A: \evalphi \phi_1 \implies \evalphi \phi_2
\end{equation*}
Drawn from def. of entailment in ``A Formal Semantics for Isorecursive and Equirecursive State Abstractions''.

\subsubsection{Implying inequality}
\begin{align*}
\\   & \phi * (e_1 = e_1) * (e_2 = e_2) \implies (e_1 \neq e_2)
\\ =~& \forall H, \rho, A:~ \evalphi \phi * (e_1 = e_1) * (e_2 = e_2) \implies \evalphi (e_1 \neq e_2)
\\ =~& \forall H, \rho, A:~  (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \implies (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge (v_1 \neq v2))
\\ =~& \forall H, \rho, A, v_1, v_2:~  (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \implies (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge (v_1 \neq v2))
\\ =~& \forall H, \rho, A, v_1, v_2:~  (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \implies (v_1 \neq v2)
\\ =~& \forall H, \rho, A, v_1, v_2:~  \neg (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi) \vee (v_1 \neq v2)
\\ =~& \forall H, \rho, A, v_1, v_2:~  \neg (\evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi \wedge (v_1 = v2))
\\ =~& \forall H, \rho, A:~ \neg (\exists v_1, v_2:~ \evale {e_1} {v_1} \wedge \evale {e_2} {v_2} \wedge \evalphi \phi \wedge (v_1 = v2))
\\ =~& \forall H, \rho, A:~ \neg (\evalphi \phi \wedge \evalphi (e_1 = e_2))
\\ =~& \forall H, \rho, A:~ \neg \evalphi \phi * (e_1 = e_2)
\\ =~& \neg \text{sat~}(\phi * (e_1 = e_2))
\end{align*}

\subsection{Footprint ($\dynamicFP {H} {\rho} {\phi} = A_d$)}
\begin{align*}
 &\dynamicFP {H} {\rho} {\true}    		&&= \emptyset
\\ &\dynamicFP {H} {\rho} {e_1 = e_2}     	&&= \emptyset
\\ &\dynamicFP {H} {\rho} {e_1 \neq e_2}  	&&= \emptyset
\\ &\dynamicFP {H} {\rho} {\acc(x.f)} 		&&= \{(o,f)\} \text{ where } \evale x o
\\ &\dynamicFP {H} {\rho} {\phi_1 * \phi_2} &&= \dynamicFP {H} {\rho} {\phi_1} \cup \dynamicFP {H} {\rho} {\phi_2}
\end{align*}

\newcommand{\dType}[4]{#1, #2 \vdash #3 : #4}

\newcommand{\sstepGeneric}[5]{({#1}, {#2}) \rightarrow^{#3} ({#4}, {#5})}
\newcommand{\sstep}[4]{\sstepGeneric {#1} {#2} {} {#3} {#4}}
\newcommand{\sstepM}[4]{\sstepGeneric {#1} {#2} * {#3} {#4}} 
\newcommand{\sstepWS}[4]{\sstepGeneric {#1} {{#2} \cdot S} {} {#3} {{#4} \cdot S}}
\newcommand{\sstepWSX}[8]{\sstepGeneric {#1} {({#2},{#3},{#4}) \cdot S} {} {#5} {({#6},{#7},{#8}) \cdot S}}

\newcommand{\Tfs}{\overline{T}~\overline{f}}
\subsection{Small-step ($\sstep H S H S$)}
\input{dynamicSemantics}
%\input{dynamicSemanticsX}

\section{Gradualization}
\subsection{Syntax}
\subsubsection{Gradual formula}
\begin{align*}
&\grad{\phi} \quad ::= \quad \phi ~|~ \withqm{\phi}
\end{align*}

Note: consider $?$ in other positions as ``self-framing delimiter'', but with semantically identical meaning.

As long as $?$ is only legal in the front though: $\phi_1 * \grad{\phi_2}$ propagates the $?$ to the very left in case $\grad{\phi_2}$ contains one.

\subsubsection{Self-framed and satisfiable formula}
\begin{align*}
&\hat{\phi} \quad \in \quad \{~ \phi ~|~ \sfrmphi \phi \wedge \text{sat~} \phi ~\}
\end{align*}

\subsection{Concretization}
\begin{align*}
&\gamma(\hat{\phi}) ~&&= \{~ \hat{\phi} ~\} \\
&\gamma(?\:*\:\phi') ~&&= \{~ \hat{\phi} ~|~ \hat{\phi} \implies \phi' ~\} \text{~~if $\phi'$ satisfiable} \\
&\gamma(\phi) \text{ undefined otherwise} \\
~\\
&\grad{\phi_1} \sqsubseteq \grad{\phi_2} \quad:\iff\quad \gamma(\grad{\phi_1}) \subseteq \gamma(\grad{\phi_2})
\end{align*}

\newcommand{\dalpha}{\dot{\alpha}}

\subsection{Abstraction}
\begin{align*}
&\alpha(\overline{\phi}) &&= \min_{\sqsubseteq} {\{~ \grad{\phi} ~|~ \overline{\phi} \subseteq \gamma(\grad{\phi}) ~\}}\\
\end{align*}
Equivalent to:
\begin{align*}
&\alpha(\{ \phi \}) &&= \phi\\
&\alpha(\overline{\phi}) &&= \dalpha(\overline{\phi}) := \sup_{\sqsubseteq} {\{~ \withqm{\phi} ~|~ \phi \in \overline{\phi} ~\}}\\
\end{align*}

Proved:
\begin{itemize}
	\item partial function
	\item sound
	\item optimal
	\item $\alpha(\gamma(\grad{\phi})) = \grad{\phi}$
    \item does this make $\langle \gamma, \alpha \rangle$ a (partial) “galois insertion”?
\end{itemize}

\subsection{Lifting functions}
Gradual lifting $\grad{f} : \grad{\phi} \rightarrow \grad{\phi}$ of a function $f : \phi \rightarrow \phi$:
$$\grad{f}(\grad{\phi}) := \alpha(\overline{f}(\gamma(\grad{\phi})))$$ 

This formal definition has drawbacks:
\begin{itemize}
    \item Calculations on infinite set (not implementable)
    \item Determine supremum of infinite set (not even clear if it exists)
\end{itemize}

Turns out above definition can be rewritten in an equivalent, computable way.

\subsubsection{Dominator Theory}
TODO: first tackle singleton case etc.

Theorem:\\
% $\gamma(\phi) = \biguplus_{i = 1..n} \gamma(\hat{\phi}_i)$
For every $\phi$, there exists a finite set of “dominators” $\dom(\phi)$, such that 
$$\gamma(\withqm{\phi}) = \bigcup_{\hat{\phi} \in \dom(f(\phi))} \gamma(\withqm{\hat{\phi}})$$
~\\

Consequence: 
\begin{align*}
\withqm{\phi} 
&= \alpha(\gamma(\withqm{\phi})) \\
&= \dalpha(\gamma(\withqm{\phi})) \\
&= \dalpha(\bigcup_{\hat{\phi} \in \dom(\phi)} \gamma(\withqm{\hat{\phi}})) \\
&= \dalpha(\bigcup_{\hat{\phi} \in \dom(\phi)} \{ \hat{\phi} \}) \\
&= \dalpha(\dom(\phi)) \\
&= \sup_{\sqsubseteq} {\{~ \withqm{\phi'} ~|~ \phi' \in \dom(\phi) ~\}}
\end{align*}
~\\
Analogous, for monotonic $f$: 
\begin{align*}
&~~~~ \alpha(\overline{f}(\gamma(\withqm{\phi}))) \\
&= \dalpha(\overline{f}(\gamma(\withqm{\phi}))) \\
&= \dalpha(\overline{f}(\bigcup_{\hat{\phi} \in \dom(\phi)} \gamma(\withqm{\hat{\phi}}))) \\
&= \dalpha(\overline{f}(\bigcup_{\hat{\phi} \in \dom(\phi)} \{ \hat{\phi} \})) \\
&= \dalpha(\overline{f}(\dom(\phi))) \\
&= \sup_{\sqsubseteq} {\{~ \withqm{f(\phi')} ~|~ \phi' \in \dom(\phi) ~\}}
\end{align*}

~\\
Re-definition of gradual lifting:
$$\grad{f}(\phi) := f(\phi)$$ 
$$\grad{f}(\withqm{\phi}) := \alpha(\overline{f}(\gamma(\withqm{\phi}))) = \dalpha(\overline{f}(\dom(\phi)))$$ 

In terms of implementation: At least no more infinite sets, need to calculating supremum remains.\\

Interesting observation:
$$\grad{f}(\withqm{\hat{\phi}}) = \dalpha(\overline{f}(\dom(\hat{\phi}))) = \dalpha(\overline{f}(\{ \hat{\phi} \})) = \dalpha(\{ f(\hat{\phi}) \}) = \,\,\withqm{f(\hat{\phi})}$$

This observation raises the question whether it is possible to generalize the equality to work with arbitrary formulas, getting rid of $\dalpha$ and calculating a supremum entirely.

%Further observations:

%~\\
%Lemmas:
%\begin{itemize}
%    \item $\dom(\phi) \subseteq \gamma(\withqm{\phi})$
%    \item $\max \gamma(\withqm{\hat{\phi}}) = \hat{\phi}$
%    \item $f : \phi \rightarrow \phi \text{ monotonic }  \implies  \max \overline{\phi} = \phi'  \implies  \max \overline{f(\phi)} = f(\phi')$
%    \item $\max \overline{\phi} = \phi'  \implies  \alpha(\overline{\phi}) \in \{ \withqm{\phi'}, \phi' \}$
%\end{itemize}

%~\\
%Also:\\
%$\alpha(\overline{f}(\gamma(\phi))) =\, f(\phi)$

\subsubsection{Generalization: Auto-liftable functions}

Goal:
Get a definition of $\grad{f}$ that is even easier to handle and implement.
Therefore we want to investigate whether, or under which circumstances 
$$\grad{f}(\grad{\phi}) = f(\grad{\phi}) \quad\quad\text{(i.e. $f$ applied to the static part of $\grad{\phi}$)}$$
holds.

We call functions $f$ satisfying above equality “auto-liftable”.

% always holds for singletons

Counterexamples:
\begin{itemize}
\item $f(\phi) = \phiCons{\phiAcc {x} {f}}{$\phi$}$ \\
    \begin{equation*}
    \grad{f}(\withqm{\phiEq{\edot{x}{f}}{3}}) = \withqm{\phiFalse} 
    ~\neq~
    \withqm{\phiCons{\phiAcc {x} {f}} {\phiEq{\edot{x}{f}}{3}}} = f(\withqm{\phiEq{\edot{x}{f}}{3}})
    \end{equation*}
    Cause: $\gamma(\withqm{\phiEq{\edot{x}{f}}{3}})$ only contains self-framed formulas, so access to $x.f$ is always included. Adding it another time results in duplicate access and therefore unsatisfiable formulas.
\item $f(\phi) = $ remove all terms containing $\ttt{x}$ \\
    \begin{equation*}
    \grad{f}(\withqm{\phiEq{a}{3}}) = \qm 
    ~\neq~
    \withqm{\phiEq{a}{3}} = f(\withqm{\phiEq{a}{3}})
    \end{equation*}
    Cause: $\phiCons{\phiEq{a}{x}}{\phiEq{x}{3}} \in \gamma(\withqm{\phiEq{a}{3}})$ and $f(\phiCons{\phiEq{a}{x}}{\phiEq{x}{3}}) = \phiTrue$.
    Abstracting from a (non-singleton) set that contains $\phiTrue$ yields $\qm$.
\end{itemize}

~\\
Required: $\alpha(\overline{f}(\gamma(\withqm{\phi}))) =\, \withqm{f(\phi)}$
Note: 

\begin{align*}
\forall \phi' \in \gamma(\withqm{f(\phi)}), \exists \phi'' \in \gamma(\withqm{\phi}), \phi' &\in \gamma(\withqm{f(\phi'')}) \\
\implies \\
\forall \phi' \in \gamma(\withqm{f(\phi)}), \exists \phi'' \in \gamma(\withqm{\phi}), \withqm{\phi'} &\sqsubseteq \,\,\withqm{f(\phi'')} \\
\implies \\
\forall \phi' \in \dom(f(\phi)), \exists \phi'' \in \dom(\phi), \withqm{\phi'} &\sqsubseteq \,\,\withqm{f(\phi'')} \\
\implies \\
\forall \phi' \in \dom(f(\phi)), \withqm{\phi'} &\sqsubseteq \sup_{\sqsubseteq} {\{~ \withqm{f(\phi')} ~|~ \phi' \in \dom(\phi) ~\}} \\
\iff \\
\sup_{\sqsubseteq} {\{~ \withqm{\phi'} ~|~ \phi' \in \dom(f(\phi)) ~\}} &\sqsubseteq \sup_{\sqsubseteq} {\{~ \withqm{f(\phi')} ~|~ \phi' \in \dom(\phi) ~\}} \\
\iff \\
\withqm{f(\phi)}  &\sqsubseteq \alpha(\overline{f}(\gamma(\withqm{\phi})))
\end{align*}

\begin{align*}
\withqm{f(\phi)} &\sqsubseteq \,\,\withqm{f(\phi)} \\
\implies \\
\forall \phi' \in \dom(\phi), \withqm{f(\phi')} &\sqsubseteq \,\,\withqm{f(\phi)} \\
\iff \\
\sup_{\sqsubseteq} {\{~ \withqm{f(\phi')} ~|~ \phi' \in \dom(\phi) ~\}} &\sqsubseteq \,\,\withqm{f(\phi)} \\
\iff \\
\alpha(\overline{f}(\gamma(\withqm{\phi}))) &\sqsubseteq \,\,\withqm{f(\phi)}
\end{align*}

For a function $f$ to be auto-liftable, the following properties are sufficient:
\begin{itemize}
    \item Monotonicity
    \item $\forall \phi' \in \gamma(\withqm{f(\phi)}), \exists \phi'' \in \gamma(\withqm{\phi}), \phi' \in \gamma(\withqm{f(\phi'')})$ 
\end{itemize}

\subsubsection{Liftable composition}
Given liftable functions $f$ and $g$, is $g \circ f$ liftable?
Monotonicity is obviously preserved.

Other condition:
\begin{align*}
\withqm{g(f(\phi))} \sqsubseteq \alpha(\overline{g}(\gamma(\withqm{f(\phi)}))) &\,\wedge
\,\,\withqm{f(\phi)} \sqsubseteq \alpha(\overline{f}(\gamma(\withqm{\phi}))) \\
\implies \\
\withqm{g(f(\phi))} \sqsubseteq \alpha(\overline{g}(\gamma(\withqm{f(\phi)}))) &\wedge
\alpha(\gamma(\withqm{f(\phi)})) \sqsubseteq \alpha(\overline{f}(\gamma(\withqm{\phi}))) \\
\implies \\
\withqm{g(f(\phi))} \sqsubseteq \alpha(\overline{g}(\gamma(\withqm{f(\phi)}))) &\wedge
\alpha(\overline{g}(\gamma(\withqm{f(\phi)}))) \sqsubseteq \alpha(\overline{g}(\overline{f}(\gamma(\withqm{\phi})))) \\
\implies \\
\withqm{g(f(\phi))} &\sqsubseteq \alpha(\overline{g}(\overline{f}(\gamma(\withqm{\phi})))) \\
\implies \\
\withqm{(g \circ f)(\phi)} &\sqsubseteq \alpha(\overline{(g \circ f)}(\gamma(\withqm{\phi}))) \\
\end{align*}


%\subsection{$(\phi, \implies)$ is semilattice}
%According to the definition of $\implies$ via $\subseteq$, we define
%\begin{align*}
%\phi_a \sqcap \phi_b = \phi_c   \quad :\iff \quad   \valphi{\phi_a} \cap \valphi{\phi_b} = \valphi{\phi_c}
%\end{align*}

%The question is, whether such $\phi_c$ always exists.



%\subsection{Concretization D (as in denotational)}
%\begin{align*}
%&\gamma(\phi) ~&&= \{~ \valphi{\phi} ~\} \\
%&\gamma(\withqm{\phi}) ~&&= \{~ \valphi{\phi\:*\:\phi_x} ~|~ \exists \phi_x : \valphi{\phi\:*\:\phi_x} \neq \emptyset ~\} \\
%& ~&&= \{~ \valphi{\phi'} ~|~ \exists \phi' : \emptyset \neq \valphi{\phi'} \wedge \phi' \implies \phi ~\} \\
%& ~&&= \{~ \valphi{\phi'} ~|~ \exists \phi' : \emptyset \neq \valphi{\phi'} \wedge \valphi{\phi'} \subseteq \valphi{\phi} ~\} \\
%\end{align*}

\subsection{Lifting implication}
Implication is the only predicate on pairs of $\phi$ occurring in our Hoare rules.\\

Looking at HAssert (the version with forwarding pre to post-condition) shows that the gradual lifting is not achieved by merely replacing the implication with gradual implication.
The gradual lifting potentially has a stronger postcondition than precondition due to filtering out of all concrete formulas that don't satisfy the implication (i.e. where the partial function HAssert is undefined).
TODO in thesis: Actually elaborate this in more detail (with example, etc.) AAAANNND show the alternative definition (that is actually correct but not ideal) that uses removal and re-addition of the asserted formula!\\

GHAssert could be defined using appropriate additional measures (e.g. manually fixing up the postcondition) but the problem can be tackled more elegantly by redesigning implication itself.\\

In general, whenever implication is used, the set of potential formulas is reduced. Without mirroring this reduction in the static system, evidence is required to make sure the reduction does not contradict assertions down the road.\\

We will create a partial function based on classical implication and give its gradual lifting.
The gradual lifting will by definition mirror reductions caused by the implication, restoring the simplicity of HAssert and especially GHAssert and removing(?) the need of evidence (TODO: evidence is now actually the return value!).\\

% The problem with arbitrary predicates (compared to partial functions) is that their lifting merely guarantees the possibility of succeeding at runtime, generating no further information about when it will succeed.
% As a result evidence is required to provide the necessary information at runtime.

\subsubsection{Implication as partial function $\imp : \phi \rightarrow \hat{\phi} \rightarrow \hat{\phi}$}
\begin{align*}
&\imp(\phi_a)(\hat{\phi}) = \hat{\phi}                   &&\text{if $\hat{\phi} \implies \phi_a$}\\
&\imp(\phi_a)(\hat{\phi}) \textit{~undefined}      &&\text{otherwise}\\
\end{align*}

\subsubsection{Gradual lifting $\grad{\imp} : \phi \rightarrow \grad{\phi} \rightarrow \grad{\phi}$}
\begin{align*}
&\grad{\imp}(\phi_a)(\grad{\phi}) 
  &&= \alpha(\overline{\imp(\phi_a)}(\gamma(\grad{\phi})))\\
& &&= \alpha(\{~ \imp(\phi_a)(\hat{\phi}) ~|~ \hat{\phi} \in \gamma(\grad{\phi}) ~\})\\
& &&= \alpha(\{~ \hat{\phi} ~|~ \hat{\phi} \in \gamma(\grad{\phi}) \wedge \hat{\phi} \implies \phi_a ~\})\\
& &&= \alpha(\{~ \hat{\phi} ~|~ \hat{\phi} \in \gamma(\grad{\phi}) \wedge \hat{\phi} \in \gamma(\withqm{\phi_a}) ~\})\\
& &&= \alpha(\gamma(\grad{\phi}) \cap \gamma(\withqm{\phi_a}))\\
\end{align*}

This definition turns out to be implementable trivially.

\newcommand{\norm}{\textrm{norm}}
\newcommand{\snorm}{\norm'}
\subsection{Gradual Normal Form}
TODO: make clear that this is specifically about GRADUAL formulas, i.e. ones containing $\qm$!!!

TODO: declare some appropriate naming conventions to distinguish

We cannot compare gradual formulas (in terms of inclusion or equality) by comparing their static parts:

TODO: example of equal gradual formulas but non-equal static parts\\

Fortunately, there exists a normal form $\norm(\withqm{\phi}) = \withqm{\snorm(\phi)}$ for any gradual formula $\withqm{\phi}$ that satisfies the following properties:
\begin{itemize}
	\item $\norm(\withqm{\phi}) = \withqm{\phi}$ (mandatory for any normal form)
	\item $\snorm(\phi)$ is well defined modulo equivalence, i.e. the normal form is unique modulo equivalence of the static part
	\item $\phi \implies \snorm(\phi)$
	\item $\snorm(\phi)$ contains no access-terms and therefore no elements of linear logic
	\item $\withqm{\phi_1} \sqsubseteq \withqm{\phi_2}  \quad\iff\quad  \snorm(\phi_1) \implies \snorm(\phi_2)$
\end{itemize} 

\subsubsection{Definition}
Recall that gradual formulas $\withqm{\phi_1}$ and $\withqm{\phi_2}$ are considered equal iff $\gamma(\withqm{\phi_1}) = \gamma(\withqm{\phi_1})$.
The normal form makes use of the fact that concretizations contain only self-framed formulas.

Lemma:
For any formula $\phi$ mentioning $\edot{$x$}{$f$}$:
$$\forall \hat{\phi} \in \gamma(\withqm{\phi}), \hat{\phi} \implies \phiAcc{$x$}{$f$}$$

In other words: Merely mentioning a field will make sure that the concretization contains appropriate framing.
This is a good starting point to justify removal of access-terms from the static part.
Note, however, that just dropping all access from the static part may not result in an equivalent gradual formula for two reasons:
\begin{description}
	\item[1. Mentioning]~\\
	Dropping $\phiAcc{$x$}{$f$}$ might result in $\edot{$x$}{$f$}$ not being mentioned in the formula anymore, so there would be no more reason for the access to be restored by concretization.
	
	\item[2. Aliasing]~\\
	In general there are different ways in which access to multiple fields can be restored (this is were linear logic plays in).
	Example: Dropping all access from $\phiCons{\phiCons{\phiAcc{a}{f}}{\phiAcc{b}{f}}}{\phiCons{\phiEq{a.f}{3}}{\phiEq{b.f}{x}}}$
	results in
	$\phiCons{\phiEq{a.f}{3}}{\phiEq{b.f}{x}}$
	which might be re-framed as
	$\phiCons{\phiCons{\phiAcc{a}{f}}{\phiEq{a}{b}}}{\phiCons{\phiEq{a.f}{3}}{\phiEq{a.f}{x}}}$.
	In other words, the possibility of aliasing may result in a variety of re-framed formulas that are not equivalent with the original one.
	% Elaborate in more detail why this is bad?
	% Also: this is where dominators play in... draw the line? How far?
\end{description}

Fortunately, we can prevent both problems from occurring by carefully preparing the static part before dropping all access, resulting in the following two-step approach:

\begin{description}
	\item[1. Enhancement]~\\
	Enrich the static part to counteract above problems, i.e. to enforce that access is restored exactly the right way.
	This is achieved by simply spelling out certain implications of the access-terms:
	\begin{description}
		\item [$\phiAcc{$x$}{$f$} \implies \phiEq{\edot{$x$}{$f$}}{\edot{$x$}{$f$}}$]~\\
		Access to a field implicitly guarantees that it actually evaluates to some (arbitrary) value.
		Note that $\phiEq{\edot{$x$}{$f$}}{\edot{$x$}{$f$}}$ is not a logical tautology (i.e. it is not implies by $\phiTrue$), since it indeed makes sure that $\edot{$x$}{$f$}$ evaluates, whereas $\phiTrue$ does not.
		The bottom line is that $\edot{$x$}{$f$}$ is being mentioned even after dropping $\phiAcc{$x$}{$f$}$, therefore solving the first problem. 
		\item [$\phiCons{\phiAcc{$x$}{$f$}}{\phiAcc{$y$}{$f$}} \implies \phiNeq{$x$}{$y$}$]~\\
		Having access to the same field of different expressions actively prevents those expressions to ever alias.
		Spelling out this restriction by adding the corresponding inequality also prevents re-framing in a way that relies on aliasing.
		The bottom line is that any valid re-framing must restore two distinct access-terms, therefore solving the second problem.
	\end{description}
	We enhance the non-linear part of our formula by spelling out above implications in every possible way, i.e. accounting for all (pairs of) access-terms.
	It is worth noting that this enhancement preserves equality of the formula as only terms are added that were implied by the original formula, anyway.
	
	\item[2. Delinearization]~\\
	All access-terms are dropped.
\end{description}



\subsubsection{Properties}
...prove properties postulated above.

equality (results directly from last prop.)

Intersection:
\begin{align*}
&\withqm{\phi_1} \sqcap \withqm{\phi_2} 
  && := \alpha(\gamma(\withqm{\phi_1}) \cap \gamma(\withqm{\phi_2})) \\
& &&  = \alpha(\gamma(\norm(\withqm{\phi_1})) \cap \gamma(\norm(\withqm{\phi_2}))) \\
& &&  = \alpha(\gamma(\withqm{\snorm(\phi_1)}) \cap \gamma(\withqm{\snorm(\phi_2)})) \\
& &&  = \alpha(\{~ \hat{\phi} ~|~ \hat{\phi} \implies \snorm(\phi_1) ~\} \cap \{~ \hat{\phi} ~|~ \hat{\phi} \implies \snorm(\phi_2) ~\}) \\
& &&  = \alpha(\{~ \hat{\phi} ~|~ \hat{\phi} \implies \snorm(\phi_1) \wedge \hat{\phi} \implies \snorm(\phi_2) ~\}) \\
& &&  = \alpha(\{~ \hat{\phi} ~|~ \hat{\phi} \implies \phiCons{$\snorm(\phi_1)$}{$\snorm(\phi_2)$} ~\}) \\
& &&  = \alpha(\gamma(\withqm{\phiCons{$\snorm(\phi_1)$}{$\snorm(\phi_2)$}})) \\
& &&  = \withqm{\phiCons{$\snorm(\phi_1)$}{$\snorm(\phi_2)$}} \\
\end{align*}

\subsubsection{Redefinition of gradual lifting}
\begin{align*}
&\grad{\imp}(\phi_a)(\grad{\phi}) 
  &&= \alpha(\gamma(\grad{\phi}) \cap \gamma(\withqm{\phi_a}))\\
&\text{is equivalent to}\\
&\grad{\imp}(\phi_a)(\phi) 
  &&= \imp(\phi_a)(\phi) 	\quad\quad\quad\text{(by definition)}\\
&\grad{\imp}(\phi_a)(\withqm{\phi}) 
%  &&= \alpha(\gamma(\withqm{\phi}) \cap \gamma(\withqm{\phi_a}))\\ &
  &&= \withqm{\phiCons{$\snorm(\phi)$}{$\snorm(\phi_a)$}} \\
\end{align*}


\subsection{Gradual Lifting}
\subsubsection{Self framing}
\begin{mathpar}
\inferrule* [Right=GSfrmNonGrad]
{A \sfrmphi \phi}
{A ~\grad{\sfrmphi}~ \phi}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GSfrmGrad]
{~}
{A ~\grad{\sfrmphi}~ \withqm{\phi}}
\end{mathpar}

\subsubsection{Implication}
\begin{mathpar}
\inferrule* [Right=GImplNonGrad]
{\phi_1 \implies \phi_2}
{\phi_1 ~\grad{\implies}~ \grad{\phi_2}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GImplGrad]
{\hat{\phi_m} \implies \phi_2 \\
 \hat{\phi_m} \implies \phi_1}
{\withqm{\phi_1} ~\grad{\implies}~ \grad{\phi_2}}
\end{mathpar}


\textbf{Minimum runtime checks}: For $\grad{\phi_1} \grad{\implies} \grad{\phi_2}$ to hold at runtime, practically just $\phi_2$ needs to hold. So that would be a valid assertion to check. Yet, we know statically that $\phi_1$ holds, so we can remove everything from the runtime check that is implied by $\phi_1$.
So in a sense, we only need to check $\phi_2 \backslash \phi_1$ at runtime (the operator can be an approximation).


%Remark: Whether second argument is gradual or not seems to be irrelevant. Interestingly, all of our later uses will also pass non-gradual formulas as second argument. Maybe the natural lifting of this predicate should only lift on first argument in the first place?

$\hat{\phi_m}$ is evidence! \\


\textbf{Consistent transitivity}

While $\implies$ is transitive, $\grad{\implies}$ is generally not.

But maybe not even necessary with smarter hoare rules?

%\subsubsection{Free Variable}
%\begin{mathpar}
%\inferrule* [Right=GNotInFV]
%{x \not\in FV(\phi)}
%{x \not\in FV(\grad{\phi})}
%\end{mathpar}

\subsubsection{Equality}
\begin{mathpar}
\inferrule* [Right=GEqStatic]
{\phi_1 = \phi_2}
{\phi_1 \approx \phi_2}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=GEqGradual]
{
\text{at least one of $\grad{\phi_1}$ or $\grad{\phi_2}$ contains $?$}
\\\\
\grad{\phi_1} \grad{\implies} \grad{\phi_2} \\
\grad{\phi_2} \grad{\implies} \grad{\phi_1}
}
{\grad{\phi_1} \approx \grad{\phi_2}}
\end{mathpar}

\subsubsection{Append}
\begin{align*}
&\text{by definition:}\\
&\grad{\phi} ~\grad{*}~ \phi_p = \alpha(\gamma(\grad{\phi}) \overline{*} \phi_p)
&~\\\\
&\text{equivalent to:}\\
&\grad{\phi} ~\grad{*}~ \phi_p = \grad{\phi} * \phi_p
      && \text{if~} \forall \hat{\phi_1}, (\hat{\phi_1} \implies \phi * \phi_p) \implies 
                    \exists \hat{\phi_2}, (\hat{\phi_2} \implies \phi \wedge \hat{\phi_1} \implies \hat{\phi_2} * \phi_p) \\
&~
      && \text{if~} \forall \hat{\phi_1} \in \gamma(\grad{\phi} * \phi_p), 
                    \exists \hat{\phi_2} \in \gamma(\grad{\phi}), \hat{\phi_1} \implies \hat{\phi_2} * \phi_p \\
&\grad{\phi} ~\grad{*}~ \phi_p \textit{~undefined}
      && \text{otherwise}
\end{align*}
% (forall p'',(good p'' /\ phiImplies p'' (snd gp1 ++ p)) ->
% exists p' , good p'  /\ phiImplies p'  (snd gp1) /\ phiImplies p'' (p' ++ p))



\subsection{Theorems}
\subsubsection{Soundness of $\alpha$}
\begin{align*}
&\forall \overline{\phi} : \overline{\phi} \subseteq \gamma(\alpha(\overline{\phi}))
\end{align*}
\subsubsection{Optimality of $\alpha$}
\begin{align*}
&\forall \overline{\phi}, \grad{\phi} : \overline{\phi} \subseteq \gamma(\grad{\phi}) \implies  \gamma(\alpha(\overline{\phi}))\subseteq
\gamma(\grad{\phi}) 
\end{align*}

\section{Theorems}
\subsection{Invariant $invariant(H, \rho, A_d, \phi)$}

\subsubsection{Phi valid}
\begin{align*}
    \sfrmphi {\phi}
\end{align*}

\subsubsection{Phi holds}
\begin{align*}
    \evalphix {H} {\rho} {A_d} {\phi}
\end{align*}

\subsubsection{Types preserved}
\begin{align*}
    \forall e, T : \sType {\phi} {e} {T}& \\
    \implies \dType {H} {\rho} {e} {T}&
\end{align*}

\subsubsection{Heap consistent}
\begin{align*}
\forall o, C, \mu, f, T :&~ 
H(o) = (C, \mu) \\
\implies&~ 
\texttt{fieldType}(C,f) = T \\
\implies&~
\dType {H} {\rho} {\mu(f)} {T}
\end{align*}

\subsubsection{Heap not total}
\begin{align*}
\exists o_{min} :&\\
\forall o \ge o_{min} :&~ o \not \in \texttt{dom}(H) \\
\wedge&~ \forall f, (o, f) \not \in A
\end{align*}

\subsection{Soundness}
\subsubsection{Progress}
\begin{align*}
\forall~ ... &:~~ \hoare {\phi_1} {s'} {\phi_2} 
\\ &\implies invariant(H_1, \rho_1, A_1, \phi_1)
\\ &\implies \exists H_2, \rho_2, A_2 : (H_1, (\rho_1, A_1, s' ; \overline{s}) \cdot S)
							\rightarrow^* (H_2, (\rho_2, A_2, \overline{s}) \cdot S)
\end{align*}

\subsubsection{Preservation}
\begin{align*}
\forall~ ... &:~~ \hoare {\phi_1} {s'} {\phi_2} 
\\ &\implies invariant(H_1, \rho_1, A_1, \phi_1)
\\ &\implies (H_1, (\rho_1, A_1, s' ; \overline{s}) \cdot S)
  \rightarrow^* (H_2, (\rho_2, A_2, \overline{s}) \cdot S)
\\ &\implies invariant(H_2, \rho_2, A_2, \phi_2)
\end{align*}

\end{document}