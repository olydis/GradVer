\documentclass[11pt,a4paper]{article}
%twocolumn
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage[margin=1.2in]{geometry}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{syntax}
\usepackage{lscape}
\usepackage{stmaryrd}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{mathpartir}
%\usepackage[pdftex]{graphicx}

%\usetikzlibrary{positioning,calc}

\DeclareMathSymbol{\mlq}{\mathord}{operators}{``}
\DeclareMathSymbol{\mrq}{\mathord}{operators}{`'}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}


\def\extraVskip{3pt}
\newenvironment{scprooftree}[1]%
  {\gdef\scalefactor{#1}\begin{center}\proofSkipAmount \leavevmode}%
  {\scalebox{\scalefactor}{\DisplayProof}\proofSkipAmount \end{center} }

\makeatletter
\providecommand{\bigsqcap}{%
  \mathop{%
    \mathpalette\@updown\bigsqcup
  }%
}
\newcommand*{\@updown}[2]{%
  \rotatebox[origin=c]{180}{$\m@th#1#2$}%
}
\makeatother




\begin{document}
\pagenumbering{arabic}

\newcommand{\Heap}{H}

\newcommand{\sfrme}{\ensuremath{\vdash_\texttt{sfrm}}}
\newcommand{\sfrmphi}{\ensuremath{\vdash_\texttt{sfrm}}}
\newcommand{\true}{\ensuremath{\texttt{true}}}
\newcommand{\vnull}{\ensuremath{\texttt{null}}}
\newcommand{\Tint}{\ensuremath{\texttt{int}}}
\newcommand{\xresult}{\ensuremath{\texttt{result}}}
\newcommand{\xthis}{\ensuremath{\texttt{this}}}
\newcommand{\new}{\ensuremath{\texttt{new}~}}
\newcommand{\assert}{\ensuremath{\texttt{assert}~}}
\newcommand{\release}{\ensuremath{\texttt{release}~}}
\newcommand{\return}{\ensuremath{\texttt{return}~}}
\newcommand{\acc}{\ensuremath{\texttt{acc}}}
\newcommand{\fields}{\ensuremath{\texttt{fields}}}
\newcommand{\mpre}{\ensuremath{\texttt{mpre}}}
\newcommand{\mpost}{\ensuremath{\texttt{mpost}}}
\newcommand{\mbody}{\ensuremath{\texttt{mbody}}}
\newcommand{\mparam}{\ensuremath{\texttt{mparam}}}
\newcommand{\mrettype}{\ensuremath{\texttt{mrettype}}}
\newcommand{\mmethod}{\ensuremath{\texttt{mmethod}}}

%\newcommand{\staticFP}[1]{\ensuremath{\texttt{static-footprint}(#1)}}
%\newcommand{\dynamicFP}[3]{\ensuremath{\texttt{footprint}_{#1,#2}(#3)}}

\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
\newcommand{\staticFP}[1]{\ensuremath{\floor{#1}}}
\newcommand{\dynamicFP}[3]{\ensuremath{\floor{#3}_{#1,#2}}}

\newcommand{\rlabel}[1]{\RightLabel{\quad #1}}
\newcommand{\dom}{\ensuremath{\texttt{dom}}}

\newcommand{\class}{\ensuremath{\texttt{class}~}}
\newcommand{\requires}{\ensuremath{\texttt{requires}~}}
\newcommand{\ensures}{\ensuremath{\texttt{ensures}~}}

\section{Syntax}

\begin{align*}
\\ &program    	&&::= \overline{cls}~\overline{s}
\\ &cls    		&&::= \class C~\{\overline{field}~\overline{method}\}
\\ &field    	&&::= T~f;
\\ &method		&&::= T~m(T~x)~contract~\{\overline{s}\}
\\ &contract	&&::= \requires \phi;~\ensures \phi;
\\ &T			&&::= \Tint ~|~ C
\\ &s			&&::= x.f := y;
				  ~|~ x := e; 
				  ~|~ x := \new C; 
				  ~|~ x := y.m(z);
\\ & &&
				  ~|~ \return x; 
				  ~|~ \assert \phi; 
				  ~|~ \release \phi;
				  ~|~ T~x;
\\ &\phi		&&::= \true
				  ~|~ e = e
				  ~|~ e \neq e
				  ~|~ \acc(x.f)
				  ~|~ x : T
				  ~|~ \phi * \phi
\\ &e			&&::= v
				  ~|~ x
				  ~|~ e.f
\\ &x			&&::= \xthis ~|~ \xresult ~|~ \langle other \rangle
\\ &v			&&::= o ~|~ n ~|~ \vnull
\\ &n			&&\in~~ \mathbb{Z}
\\				  
\\ &H			&&\in~~ (o \rightharpoonup (C,\overline{(f \rightharpoonup v)}))
\\ &\rho		&&\in~~ (x \rightharpoonup v)
\\ &A_s			&&::= \overline{(x, f)}
\\ &A_d			&&::= \overline{(o, f)}
\\ &S			&&::= (\rho, A_d, \overline{s}) \cdot S ~|~ nil
\end{align*}

\section{Static semantics}
\subsection{Expressions ($A_s \sfrme e$)}
\input{staticExpression}

\subsection{Formulas ($A_s \sfrme \phi$)}
\input{staticFormula}

\begin{mathpar}
\inferrule* [Right=WFSepOp]
{
A_s \sfrmphi \phi_1 \\ 
A_s \cup \staticFP {\phi_1} \sfrmphi \phi_2
}
{A_s \sfrmphi \phi_1 * \phi_2}
\end{mathpar}

\subsubsection{Implication ($\phi_1 \dot{\implies} \phi_2$)}
Conservative approx. of $\phi_1 \implies \phi_2$.

\subsection{Footprint ($\staticFP {\phi} = A_s$)}
\begin{align*}
 &\staticFP {\true}    		&&= \emptyset
\\ &\staticFP {e_1 = e_2}     	&&= \emptyset
\\ &\staticFP {e_1 \neq e_2}  	&&= \emptyset
\\ &\staticFP {\acc(x.f)} 		&&= \{(x,f)\}
\\ &\staticFP {\phi_1 * \phi_2} 	&&= \staticFP {\phi_1} \cup \staticFP {\phi_2}
\end{align*}

\newcommand{\sType}[3]{#1 \vdash #2 : #3}
\subsection{Type ($\sType {\phi} {e} {T}$)}
\begin{mathpar}
\inferrule* [Right=STValue]
{~}
{\sType {\phi} {v_T} {T}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=STVar]
{\phi \implies (x : T)}
{\sType {\phi} {x} {T}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=STField]
{ \sType {\phi} {e} {C}
\\ \vdash C.f : T}
{\sType {\phi} {e.f} {T}}
\end{mathpar}

\newcommand{\hoare}[3]{\vdash\{#1\}#2\{#3\}}
\subsection{Hoare ($\hoare {\phi} {\overline s} {\phi}$)}
\begin{mathpar}
\inferrule* [Right=HSec]
{
\hoare {\phi_p} {s_1} {\phi_{q1}} \\ 
\phi_{q1} \implies \phi_{q2} \\
\hoare {\phi_{q2}} {s_2} {\phi_r}
}
{\hoare {\phi_p} {s_1;s_2} {\phi_r}}
\end{mathpar}

\input{staticSemantics}

\section{Dynamic semantics}
\newcommand{\evalex}[4]{#1,#2 \vdash #3 \Downarrow #4}
\newcommand{\evale}[2]{H,\rho \vdash #1 \Downarrow #2}
\subsection{Expressions ($\evale {e} {v}$)}

\begin{mathpar}
\inferrule* [Right=EEVar]
{~}
{\evale {x} {\rho(x)}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=EEValue]
{~}
{\evale {v} {v}}
\end{mathpar}

\begin{mathpar}
\inferrule* [Right=EEAcc]
{\evale {x} {o}}
{\evale {x.f} {H(o)(f)}}
\end{mathpar}

\newcommand{\evalphix}[4]{#1,#2,#3 \vDash #4}
\newcommand{\evalphi}{\evalphix H \rho A}
\subsection{Formulas ($\evalphi \phi$)}
\input{dynamicFormula}

\begin{mathpar}
\inferrule* [Right=EASepOp]
{
A_1 = A \backslash A_2 \\
\evalphix H \rho {A_1} {\phi_1} \\
\evalphix H \rho {A_2} {\phi_2}
}
{\evalphi {\phi_1 * \phi_2}}
\end{mathpar}


\subsubsection{Implication ($\phi_1 \implies \phi_2$)}
\begin{equation*}
\phi_1 \implies \phi_2
\quad\quad \iff \quad\quad
\forall H, \rho, A: \evalphi \phi_1 \implies \evalphi \phi_2
\end{equation*}
Drawn from def. of entailment in ``A Formal Semantics for Isorecursive
and Equirecursive State Abstractions''.

\subsection{Footprint ($\dynamicFP {H} {\rho} {\phi} = A_d$)}
\begin{align*}
 &\dynamicFP {H} {\rho} {\true}    		&&= \emptyset
\\ &\dynamicFP {H} {\rho} {e_1 = e_2}     	&&= \emptyset
\\ &\dynamicFP {H} {\rho} {e_1 \neq e_2}  	&&= \emptyset
\\ &\dynamicFP {H} {\rho} {\acc(e.f)} 		&&= \{(o,f)\} \text{ where } \evale e o
\\ &\dynamicFP {H} {\rho} {\phi_1 * \phi_2} &&= \dynamicFP {H} {\rho} {\phi_1} \cup \dynamicFP {H} {\rho} {\phi_2}
\end{align*}

\newcommand{\dType}[4]{#1, #2 \vdash #3 : #4}
\subsection{Type ($\dType {H} {\rho} {e} {T}$)}
\begin{mathpar}
\inferrule* [Right=DTEval]
{ \evale {e} {v_T} }
{\dType {H} {\rho} {e} {T}}
\end{mathpar}

\newcommand{\sstepGeneric}[5]{({#1}, {#2}) \rightarrow^{#3} ({#4}, {#5})}
\newcommand{\sstep}[4]{\sstepGeneric {#1} {#2} {} {#3} {#4}}
\newcommand{\sstepM}[4]{\sstepGeneric {#1} {#2} * {#3} {#4}} 
\newcommand{\sstepWS}[4]{\sstepGeneric {#1} {{#2} \cdot S} {} {#3} {{#4} \cdot S}}
\newcommand{\sstepWSX}[8]{\sstepGeneric {#1} {({#2},{#3},{#4}) \cdot S} {} {#5} {({#6},{#7},{#8}) \cdot S}}

\newcommand{\Tfs}{\overline{T}~\overline{f}}
\subsection{Small-step ($\sstep H S H S$)}
\input{dynamicSemantics}
%\input{dynamicSemanticsX}

\section{Gradualization}
\subsection{Syntax}
\begin{align*}
&\widetilde{\phi} \quad ::= \quad \phi ~|~ \phi\:*\:?
\end{align*}
Note: allowing $?$ at different position is hardly useful (no difference for dyn. semantics, useless difference in static semantics).

\subsection{Concretization A}
\begin{align*}
&\gamma(\phi) ~&&= \{~ \phi' ~|~ \phi' \iff \phi ~\} \\
&\gamma(\phi\:*\:?) ~&&= \{~ \phi' ~|~ \exists \phi_x : \phi\:*\:\phi_x \iff \phi' ~\} \\
&  ~&&= \{~ \phi' ~|~ \phi' \implies \phi ~\} \\
\end{align*}

\subsection{Abstraction (to show: set of $\phi$s is poset - can we even say that on infinite sets?)}
\begin{align*}
&\alpha(\overline{\phi}) = (\sqcap \overline{\phi})\:*\:? \\
\end{align*}

\subsection{Concretization B}
\begin{align*}
&\gamma(\phi) ~&&= \{~ \phi ~\} \\
&\gamma(\phi\:*\:?) ~&&= \{~ \phi\:*\:\phi_x ~|~ \phi_x ~\} \\
\end{align*}

\subsection{Abstraction}
\begin{align*}
&\alpha(\{~ \phi ~\}) = \phi \\
&\alpha(\{~ \overline{\phi} ~\}) = \texttt{lcp}(\overline{\phi}) \\
\end{align*}

\subsection{Theorems}
\subsubsection{Soundness}
\begin{align*}
&\forall \overline{\phi} : \overline{\phi} \subseteq \gamma(\alpha(\overline{\phi}))
\end{align*}
\subsubsection{Optimality}
\begin{align*}
&\forall \overline{\phi}, \widetilde{\phi} : \overline{\phi} \subseteq \gamma(\widetilde{\phi}) \implies \gamma(\widetilde{\phi}) \subseteq \gamma(\alpha(\overline{\phi}))
\end{align*}

\subsection{Concretization W (as in wrong)}
\begin{align*}
&\gamma(\phi) ~&&= \{~ (H,\rho,A) ~|~ \evalphi \phi ~\} \\
&\gamma(\phi\:*\:?) ~&&= \{~ (H,\rho,A) ~|~ \evalphi \phi ~\} \\
\end{align*}


\section{Theorems}
\subsection{Invariant $invariant(H, \rho, A_d, \phi)$}
\subsubsection{Heap consistent}
\begin{align*}
\forall x, o, C : 
	\rho(x) = o_C &\implies\\
      \exists f_C, m :&~ 
        \texttt{fields}(C) = f_C \\
      \wedge&~ H(o_C) = (C, m) \\
      \wedge&~(\forall (T, f) \in f_C : \dType {H} {\rho} {m(f)} {T})
\end{align*}

\subsubsection{Phi holds}
\begin{align*}
    \evalphix {H} {\rho} {A_d} {\phi}
\end{align*}

\subsubsection{Types preserved}
\begin{align*}
    \forall e, T : \sType {\phi} {e} {T}& \\
    \implies \dType {H} {\rho} {e} {T}&
\end{align*}

\subsection{Soundness}
\subsubsection{Progress}
\begin{align*}
\forall~ ... &:~~ \hoare {\phi_1} {s'} {\phi_2} 
\\ &\implies invariant(H_1, \rho_1, A_1, \phi_1)
\\ &\implies \exists H_2, \rho_2, A_2 : (H_1, (\rho_1, A_1, s' ; \overline{s}) \cdot S)
							\rightarrow^* (H_2, (\rho_2, A_2, \overline{s}) \cdot S)
\end{align*}

\subsubsection{Preservation}
\begin{align*}
\forall~ ... &:~~ \hoare {\phi_1} {s'} {\phi_2} 
\\ &\implies invariant(H_1, \rho_1, A_1, \phi_1)
\\ &\implies (H_1, (\rho_1, A_1, s' ; \overline{s}) \cdot S)
  \rightarrow^* (H_2, (\rho_2, A_2, \overline{s}) \cdot S)
\\ &\implies invariant(H_2, \rho_2, A_2, \phi_2)
\end{align*}

\end{document}